# Модель кошельков: создание, безопасность и удобство

## Переосмысление

Сейчас в протоколе Елена **ключи хранятся на узле**. Web-кошелёк и gateway лишь показывают баланс и отправляют команды узлу — подпись ставит узел. Это даёт два следствия:

1. **Один узел = один кошелёк.** Чтобы у каждого пользователя был свой кошелёк, каждый должен запускать свой узел (или доверять общему узлу и защищать доступ API-ключом).
2. **Удобство vs контроль.** Общий сайт (один кошелёк на всех) максимально прост, но средства контролирует владелец узла; свой узел даёт полный контроль, но требует настройки.

Ниже — как устроены сценарии, как их безопасно использовать и в какую сторону развивать модель.

---

## Текущая модель: кошелёк узла

- **Ключи:** пара Dilithium3 хранится в файле на узле (`data_dir/wallets/<имя>.key`).
- **Подпись:** все исходящие транзакции подписываются этим ключом на узле.
- **Web/Gateway:** только интерфейс к одному узлу; баланс и адрес — у узла, отправка — команда узлу «send to amount».

### Сценарии использования

| Сценарий | Кто создаёт кошелёк | Удобство | Безопасность | Для кого |
|----------|----------------------|----------|--------------|----------|
| **Свой узел** | Пользователь (CLI или Docker) | Ниже: нужно установить и запустить узел | Высокая: ключи только у вас | Те, кому нужен полный контроль |
| **Общий сайт** | Владелец сайта (один узел на всех) | Высокое: только браузер | Зависит от владельца и API-ключа | Демо, внутренние сервисы |
| **Docker** | Контейнер при первом запуске | Среднее: одна команда `up` | Как «свой узел», если данные не отдают | Быстрый старт с одним кошельком |

---

## Безопасность

### Что важно в любом сценарии

1. **Резервная копия ключа**  
   При «своём» кошельке (свой узел / свой Docker) файл `wallets/<имя>.key` — единственный способ восстановить доступ. Копируйте его в безопасное место и храните так же, как пароль от банка. Кто владеет файлом — владеет средствами.

2. **Защита от трат на общем сайте**  
   Если один gateway обслуживает многих пользователей, включите **GATEWAY_API_KEY**. Тогда только тот, кто знает ключ (обычно только вы), может отправлять и стейкать. Баланс и адрес по-прежнему видны всем — это нормально для «одного кошелька на всех».

3. **Admin-порт узла не в интернет**  
   Порт, на котором слушает узел (admin RPC), должен быть доступен только с того же хоста, где крутится gateway (или надёжная сеть). Иначе любой сможет отправлять команды узлу.

4. **HTTPS**  
   Gateway и веб-кошелёк лучше отдавать по HTTPS, чтобы трафик (в том числе API-ключ) не перехватывался.

### Удобство без потери безопасности

- **Свой узел:** один раз настроили — дальше пользуетесь как обычным кошельком в браузере; резервная копия `.key` делается редко, но обязательна.
- **Общий сайт:** один раз ввели API-ключ в настройках кошелька — дальше отправка и стейкинг без повторного ввода (ключ в sessionStorage). Не передавайте ключ третьим лицам.

---

## Удобство создания кошелька

Сегодня «создать кошелёк» значит одно из двух:

- **Реально создать ключи:** только через узел (CLI `elena-core wallet <имя>` или автоматически при первом запуске узла/Docker). Web-интерфейс ключи не создаёт.
- **«Увидеть» кошелёк на общем сайте:** зайти в «Получить» — там адрес того единственного кошелька узла; отдельного «своего» кошелька у пользователя нет.

Поэтому в интерфейсе и в документации важно явно говорить:

- «Здесь один кошелёк на всех — это кошелёк владельца сайта. Чтобы получить свой отдельный кошелёк, нужно запустить свой узел (см. Помощь / документацию).»
- Давать короткую пошаговую инструкцию: свой узел (CLI/Docker), резервная копия, при необходимости API-ключ.

---

## Возможное развитие: кошелёк в браузере

Чтобы у каждого пользователя был **свой** кошелёк без запуска узла, ключи должны храниться у пользователя (например, в браузере), а узел — только принимать уже подписанные транзакции и распространять их по сети.

**Идея:**

1. **Генерация ключей в браузере** (WebCrypto или WASM-сборка Dilithium3).
2. **Хранение:** зашифрованный ключ в localStorage или только в сессии; опционально экспорт/резервная фраза.
3. **Отправка:** браузер собирает транзакцию (данные с графа — anchor, parents — запрашивает у gateway/узла), подписывает локально и отправляет на gateway уже подписанную транзакцию.
4. **Gateway/узел:** новый метод вида «submit signed tx» — проверка подписи и рассылка по сети, без хранения ключей.

**Плюсы:** у каждого пользователя свой кошелёк, не нужно поднимать узел; gateway и узел не видят секретные ключи.  
**Минусы:** нужна реализация Dilithium3 в браузере (WASM/JS), доработка узла (приём готовых подписей) и gateway (подготовка tx + приём подписанной tx), плюс понятный UX резервной копии/восстановления.

Пока такой режим не реализован, акцент — на **чётком объяснении текущей модели** (кошелёк узла, один на узел или один на всех) и на **безопасности и удобстве** в рамках неё: резервная копия, API-ключ, HTTPS, не светить admin-порт.
